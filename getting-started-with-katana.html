<!DOCTYPE html>
<html lang="ru">
<head>
          <title>tkirill's blog</title>
        <meta charset="utf-8" />





</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="">tkirill's blog <strong></strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/getting-started-with-katana.html" rel="bookmark"
         title="Permalink to Приступая к работе с Katana Project">Приступая к работе с Katana Project</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2014-12-03T00:00:00">
      Wed 03 December 2014
    </abbr>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <h1>Приступая к работе с Katana Project</h1>
<p>В 2002, когда впервые был выпущен ASP.NET, времена были другие.  Интернет всё ещё был в относительно младенческом состоянии, около 569 миллионов пользователей проводили в среднем 46 минут в день на приблизительно 3 миллионах сайтов.  Те же самые измерения, проведённые всего десятью годами позже, показывают приблизительно 2.27 миллиардов пользователей, в среднем тратящими ежедневно 4 часа на 555 миллионах сайтов (см. <a href="http://bit.ly/MY7GzO">bit.ly/MY7GzO</a>).</p>
<p>Этот рост, конечно же, привёл к соответствующим изменениям в потребностях разработчиков в смысле фреймворков, инструментов и рантаймов, которые они используют для разработки и запуска веб-приложений.  Современные веб-приложения должны развиваться быстро, используя фишки из множества разных компонентов и фреймворков, а также использовать малое количество ресурсов, чтобы эффективно работать в больших облачных системах.</p>
<p>Главным мотивом для Katana Project является обеспечение того, чтобы ASP.NET мог ответить этим текущим и будущим потребностям.</p>
<h2>Что такое Katana?</h2>
<p>Проект Katana на самом деле были начат не в Microsoft, а в open-source проекте Open Web Interface for .NET (OWIN), спецификации, которая определяет взаимодействие между веб-сервером и компонентами приложения (см. <a href="http://owin.org">owin.org</a>).  Так как цель спецификации – стимулировать обширную и живую экосистему .NET-серверов и программных компонентов, то всё взаимодействие между сервером и приложением сводится к небольшому набору типов и единственной функции, известной как application delegate, или AppFunc:</p>
<div class="highlight"><pre><span class="n">using</span> <span class="n">AppFunc</span> <span class="o">=</span> <span class="n">Func</span><span class="o">&lt;</span><span class="n">IDictionary</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Task</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>


<p>Каждый компонент OWIN-приложения предоставляет серверу application delegate.  Затем компоненты сцепляются вместе в конвеер, в который OWIN-сервер посылает запросы.  Все компоненты в конвеере должны быть асинхронными, чтобы эффективно использовать ресурсы, и это отражено в application delegate, возвращающим Task.</p>
<p>Все состояния, включая состояния приложения, запроса, сервера и так далее, содержатся в <code>IDictionary&lt;string, object&gt;</code>, передаваемом в application delegate.  Эта структура данных, известная как environment dictionary, передаётся от компонента к компоненту по ходу того, как запрос проходит через конвеер.  Не отменяя того, что любые key/value данные могут быть вставлены в environment dictionary, спецификация OWIN определяет ключи для некоторых ключевых элементов HTTP.</p>
<table>
<thead>
<tr>
<th>Ключ</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td>"owin.RequestBody"</td>
<td><code>Stream</code>-объект с телом запроса, если оно есть.  В случае, когда его нет, в качестве заглушки используется <code>Stream.Null</code>.</td>
</tr>
<tr>
<td>"owin.RequestHeaders"</td>
<td><code>IDictionary&lt;string, string[]&gt;</code> с заголовками запроса.</td>
</tr>
<tr>
<td>"owin.RequestMethod"</td>
<td>Строка, содержащая HTTP-метод запроса (например, GET или POST).</td>
</tr>
<tr>
<td>"owin.RequestPath"</td>
<td>Строка, содержащая путь запроса.  Путь должен указываться относителено "корня" application delegate.</td>
</tr>
<tr>
<td>"owin.RequestPathBase"</td>
<td>Строка, содержащая часть пути запроса, соответствующую "корню" application delegate.</td>
</tr>
<tr>
<td>"owin.RequestProtocol"</td>
<td>Строка, содержащая название и версию протокола (например, HTTP/1.0 или HTTP/1.1).</td>
</tr>
<tr>
<td>"owin.RequestQueryString"</td>
<td>Строка, содержащая query string из урла HTTP-запроса, без "?" в начале (например, foo=bar&amp;baz=quux). Может быть пустой строкой.</td>
</tr>
<tr>
<td>"owin.RequestScheme"</td>
<td>Строка, содержащая схему URI, использующуюся в запросе (например, HTTP or HTTPS).</td>
</tr>
</tbody>
</table>
<p>Закрепление базового набора key-value пар в environment dictionary даёт авторам множества разных фреймворков и компонентов возможность взаимодействовать внутри конвеера OWIN без навязывания соглашений о строгой модели .NET-объекта, вроде HttpContextBase в ASP.NET MVC или HttpRequestMessage/HttpResponseMessage in ASP.NET Web API.</p>
<p>Эти два элемента -- application delegate и environment dictionary -- и образуют спецификацию OWIN.  Katana -- это набор OWIN-компонентов и фреймворков, созданных и распростроняемых Microsoft.</p>
<p>Компоненты Katana можно отобразить в виде стека:</p>
<p><img alt="Katana architectural stack" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure2_hires%28en-us,MSDN.10%29.png" /></p>
<p>Стек состоит из следующих слоёв:</p>
<dl>
<dt>Host</dt>
<dd>Процесс, который запускает приложение и который может быть чем угодно: от IIS или отдельного исполняемого файла до вашей единственной и неповторимой программы.  Host отвечает за запуск, загрузку остальных компонентов OWIN и корректную остановку.</dd>
<dt>Server</dt>
<dd>Ответственен за привязку к TCP-порту, создание environment dictionary и передачу запросов в OWIN-конвеер.</dd>
<dt>Middleware</dt>
<dd>Под это название попадают все компоненты, обрабатывающие запросы в OWIN-конвеере.  Middleware может разнится от несложного компонента для сжатия до целого фреймворка вроде ASP.NET Web API, хотя с точки зрения сервера это всегда будет ни больше ни меньшев как просто компонент, который предоставляет application delegate.</dd>
<dt>Application</dt>
<dd>Это ваш код.  Так как Katana -- это не замена для ASP.NET, а новый способ объединять и запускать компоненты, то существующие ASP.NET Web API и SignalR приложения останутся без изменений, эти фреймворки умеют встраиватся в конвеер OWIN.  Фактически, для таких приложений Katana будет видна всего лишь как небольшой конфигурационный класс.</dd>
</dl>
<p>Архитектурно Katana разделена так, что каждый слой может быть легко заменён, часто без перекомпиляции кода.  При обработке HTTP-запроса слои работают вместе примерно так:</p>
<p><img alt="katana-data-flow" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure3_hires(en-us,MSDN.10).png" /></p>
<h2>Создание современного веб-приложения с Katana</h2>
<p>Современные веб-приложения зачастую используют 4 вещи:</p>
<ol>
<li>Серверная генерация разметки</li>
<li>Раздача статичных файлов</li>
<li>Web API для обработки AJAX запросов</li>
<li>Messaging в реальном времени</li>
</ol>
<p>Для того, чтобы создать приложение со всеми этими возможностями, требуется несколько разных фреймворков, специально приспособленных для соответствующей функциональности.  Однако, составление приложения из таких фреймворков часто может оказаться трудным, и сейчас это требует хостинга различных частей приложения под IIS с возможной изоляцией их друг от друга с помощью applications и virtual directories.</p>
<p>В противоположность этому, Katana предлагает вам собрать современное веб-приложение, используя широкий набор разных веб-технологий, и затем захостить это приложение любым желаемым способом, выставив его под одним HTTP endpoint.  Это даёт несколько преимуществ:</p>
<ul>
<li>Простой деплой: он включает в себя единственное приложение вместо отдельных приложений для каждой технологии.</li>
<li>Вы можете добавить другие возможности, например, аутентификацию, которая может быть применена ко всем нижележащим компонентам в конвеере.</li>
<li>Разные компоненты, неважно, от Microsoft или сторонние, могут работать с одним и тем состоянием запроса через environment dictionary.</li>
</ul>
<p>Теперь я пройдусь по примеру приложения из области, с который вы должны быть знакомы: баг-трекинг.  Приложение будет показывать набор багов в разных состояниях - отложен, в работе и сделан - и позволит мне перемещать баги между ними.  Также, так как одновременно работать с багом может множество разных людей, то приложение будет обновлять все браузеры в реальном времени при изменении состояния бага.  Вот что я буду использовать для построения приложения:</p>
<ul>
<li>Nancy (<a href="http://nancyfx.org">nancyfx.org</a>) для серверной генерации разметки и раздачи статики.</li>
<li>ASP.NET Web API (<a href="http://asp.net/web-api">asp.net/web-api</a>) для обработки AJAX-запросов.</li>
<li>SignalR (<a href="http://signalr.net">signalr.net</a>) для обмена сообщениями в реальном времени.</li>
</ul>
<p>Я не собираюсь тратить много времени на вёрстку и клиентские скрипты, поэтому дополнительно я буду использовать Knockout.js для отделения HTML-разметки от данных, поступающих из API и SignalR.</p>
<p>Главное, о чём стоит помнить - это то, что я собираю все эти фреймворки в один OWIN-конвеер, так что если мне станут доступны новые возможности, то я добавлю их в приложение простой вставкой их в конвеер.</p>
<h2>Приступаем к работе</h2>
<p>Одна из целей Katana -- позволить вам лучше контролировать возможности, добавленные в ваше приложение (и, следовательно, ваши затраты в смысле ресурсов на обработку каждого запроса).  Помня об этом, я начну создавать новый пустой ASP.NET Web app проект в Visual Studio 2013:</p>
<p><img alt="begin-creating-project" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure%204_hires(en-us,MSDN.10).png" /></p>
<p>Шаблоны Web-проектов, даже пустые, помогают в том, что по-умолчанию складывают скомпилированные сборки прямо в каталог /bin вместо /bin/debug, что часто встречается в проектах других типов.  Стандартный Katana-хост ищет сборки в каталоге /bin.  Вы можете создать приложение, основанное на Katana, в виде библиотеки классов, но тогда вам придётся либо поменять свойства проекта так, чтобы они подходили под эту структуру, либо предоставить собственный специфический загрузчик приложений, который сможет отыскать сборки и типы в другой структуре каталогов.</p>
<p>Далее я сделаю серверную генерацию разметки с помощью веб-фреймворка Nancy.</p>
<p>Лаконичный синтаксис Nancy позволяет легко и быстро строить HTTP-сайты и сервисы.  Но что более важно для этого упражнения -- это то, что, подобно ASP.NET Web API, Nancy не зависит от System.Web.dll и приспособлен для запуска в конвеере OWIN.  Фреймворки вроде ASP.NET MVC имеют зависимости от System.Web.dll (на момент написания этой статьи), что делает их менее годными для хостинга вне IIS.</p>
<p>Зачастую, когда вы добавляете новый функционал в приложение, вы начинаете с установки NuGet пакета (вы можете прочитать подробнее про NuGet на <a href="http://docs.nuget.org">docs.nuget.org</a>).  На момент написания многие используемые здесь пакеты находились в пре-релиз версиях, поэтому проверьте, что отображение пре-релиз пакетов включено в диалоговом окне NuGet.</p>
<p>Добавить Nancy в приложение я могу простой установкой одноимённого NuGet-пакета.  Однако, так как я хочу ещё запускать Nancy в конвеере OWIN, я установлю пакет Nancy.Owin (<a href="http://nuget.org/packages/nancy.owin">nuget.org/packages/nancy.owin</a>).  Он установит пакет Nancy как зависимость и предоставит дополнительные хелперы для настройки Nancy в конвеере OWIN.</p>
<p>Затем мне нужно создать модуль Nancy (похож на контроллер из Model-View-Controller, или MVC) для обработки запросов, а также view для отображения чего-нибудь в браузере.  Вот код модуля (HomeModule.cs):</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">HomeModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="n">HomeModule</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="n">var</span> <span class="n">model</span> <span class="o">=</span> <span class="n">new</span> <span class="p">{</span> <span class="n">title</span> <span class="o">=</span> <span class="s">&quot;We&#39;ve Got Issues...&quot;</span> <span class="p">};</span>
      <span class="k">return</span> <span class="n">View</span><span class="p">[</span><span class="s">&quot;home&quot;</span><span class="p">,</span> <span class="n">model</span><span class="p">];</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Как вы можете видеть, модуль говорит, что запросы на корень приложения ("/") должны быть обработаны анонимным делегатом, определённым в соответствующей лямбде.  Эта функция создаёт модель с заголовком страницы и говорит Nancy отрендерить view "home", передавая в неё модель. View, показанная ниже, вставляет заголовок из модели и в заголовок страницы, и в тег h1:</p>
<div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;title&gt;</span>@Model.title<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;header&gt;</span>
      <span class="nt">&lt;h1&gt;</span>@Model.title<span class="nt">&lt;/h1&gt;</span>   
    <span class="nt">&lt;/header&gt;</span>
    <span class="nt">&lt;section&gt;</span>
      <span class="nt">&lt;h2&gt;</span>Backlog<span class="nt">&lt;/h2&gt;</span>
      <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;bugs&quot;</span> <span class="na">id=</span><span class="s">&quot;backlog&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;li&gt;</span>a bug<span class="nt">&lt;/li&gt;</span>
      <span class="nt">&lt;/ul&gt;</span>
    <span class="nt">&lt;/section&gt;</span>
    <span class="nt">&lt;section&gt;</span>
      <span class="nt">&lt;h2&gt;</span>Working<span class="nt">&lt;/h2&gt;</span>
      <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;bugs&quot;</span> <span class="na">id=</span><span class="s">&quot;working&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;li&gt;</span>a bug<span class="nt">&lt;/li&gt;</span>
      <span class="nt">&lt;/ul&gt;</span>
    <span class="nt">&lt;/section&gt;</span>
    <span class="nt">&lt;section&gt;</span>
      <span class="nt">&lt;h2&gt;</span>Done<span class="nt">&lt;/h2&gt;</span>
      <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;bugs&quot;</span> <span class="na">id=</span><span class="s">&quot;done&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;li&gt;</span>a bug<span class="nt">&lt;/li&gt;</span>
      <span class="nt">&lt;/ul&gt;</span>
    <span class="nt">&lt;/section&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>


<p>За более подробной информацией об этих листингах загляните, пожалуйста, в документацию Nancy.</p>
<p>Теперь, когда у меня есть базовая функциональность Nancy, мне нужно организовать конвеер OWIN и встроить в него модуль Nancy.  Для этого мне нужно установить хост Katana и серверные компоненты, а затем написать немного кода для связки конвеера OWIN и Nancy.</p>
<p>В качестве хоста Katana и серверных компонентов я буду использовать IIS Express и System.Web, так как они имеют родную поддержку в Visual Studio и вдовабок позволяют использовать удобную кнопку F5 при разработке приложения.  Я добавлю System.Web-хост в проект с помощью установки NuGet-пакета Microsoft.Owin.Host.SystemWeb (<a href="http://bit.ly/19EZ2Rw">bit.ly/19EZ2Rw</a>).</p>
<p>Стандартные компоненты Katana используют разные соглашения по загрузке и запуску OWIN-приложений, включая startup class.  Когда хост Katana загружает OWIN-приложение, он находит и запускает startup class согласно следующих правил (в порядке приоритета):</p>
<ul>
<li>Если Web.config содержит настройку с ключом "owin:AppStartup" в appSettings, то загрузчик возьмёт указанное значение.  Оно должно быть валидным именем .NET-типа.</li>
<li>Если сборка содержит аттрибут <code>[assembly: OwinStartup(typeof(MyStartup))]</code>, загрузчик возьмёт указанный в нём тип.</li>
<li>Если никакое из этих условий не сработает, то загрузчик пройдётся по всем загруженным сборкам в поиска типа Startup, у которого есть метод с сигнатурой <code>void Configure(IAppBuilder app)</code>.</li>
</ul>
<p>Для этого примера я позволю загрузчику просканировать сборки в поисках класса.  Однако, будет разумным использовать appSettings или атрибут сборки во избежание ненужного сканирования в случае, когда в вашем проекте много типов и сборок.</p>
<p>Я создам startup class, который будет инициализировать мой OWIN-конвеер и добавлять Nancy как компонент конвеера.  Я создаю новый класс Startup и добавляю конфигурационный метод следующим образом:</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Startup</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="kt">void</span> <span class="n">Configuration</span><span class="p">(</span><span class="n">IAppBuilder</span> <span class="n">app</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">app</span><span class="p">.</span><span class="n">UseNancy</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>UseNancy -- это extension method, доступный из NuGet-пакета Nancy.Owin.  Многие библиотеки middleware предоставляют похожие удобные extension methods, упрощающие процесс настройки, но вам никто не запрещает добавлять middleware с помощью метода Use у IAppBuilder.</p>
<p>На данном этапе вы можете запустить проект в Visual Studio использую F5 и посмотреть, что он хоть пока что и не заставляет ронять челюсть на пол, но вы уже имеете полно-функциональное веб-приложение.  Сейчас конвеер OWIN состоит из одного компонента, Nancy, как это показано ниже:</p>
<p><img alt="OWIN pipeline with Nancy" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure6_hires(en-us,MSDN.10).png" /></p>
<h2>Добавляем данные с помощью ASP.NET Web API</h2>
<p>Пока что HTML view состоит в основном из статичной разметки.  Сейчас я выдам пользователям реальные баги для работы.  Во многих современных веб-приложениях задача по доставке данных в клиентский браузер перешла от фреймворков для серверной генерации разметки (вроде Nancy) к отдельному API.  В этом случае браузер сразу же после загрузки HTML-страницы выполняет JavaScript, который данные из API и динамически строит HTML-разметку.</p>
<p>Я начну с разработки API на фреймворке ASP.NET Web API.  Как обычно, первым делом нужно установить NuGet-пакет.  Пакет этот называется Microsoft.AspNet.WebApi.Owin (<a href="http://bit.ly/1dnocmK">bit.ly/1dnocmK</a>) и он позволит легко встроить ASP.NET Web API в мой OWIN-конвеер.  Фреймворк ASP.NET Web API установится как зависимость.  После установки, я создам простое API:</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">class</span> <span class="nx">BugsController</span> <span class="p">:</span> <span class="nx">ApiController</span>
<span class="p">{</span>
  <span class="nx">IBugsRepository</span> <span class="n">_bugsRepository</span> <span class="o">=</span> <span class="nb">new</span> <span class="nx">BugsRepository</span><span class="p">();</span>
  <span class="k">public</span> <span class="nf">IEnumerable</span><span class="o">&lt;</span><span class="nx">Bug</span><span class="o">&gt;</span> <span class="nb">Get</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nx">_bugsRepository.GetBugs</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="err">[</span><span class="nx">HttpPost</span><span class="p">(</span><span class="s2">&quot;api/bugs/backlog&quot;</span><span class="p">)</span><span class="cp">]</span>
  public Bug MoveToBacklog(<span class="cp">[</span><span class="nx">FromBody</span><span class="cp">]</span> int id)
  {
    var bug = _bugsRepository.GetBugs().First(b=&gt;b.id==id);
    bug.state = &quot;backlog&quot;;
    return bug;
  }
  <span class="cp">[</span><span class="nx">HttpPost</span><span class="p">(</span><span class="s2">&quot;api/bugs/working&quot;</span><span class="p">)</span><span class="cp">]</span>
  public Bug MoveToWorking(<span class="cp">[</span><span class="nx">FromBody</span><span class="cp">]</span> int id)
  {
    var bug = _bugsRepository.GetBugs().First(b =&gt; b.id == id);
    bug.state = &quot;working&quot;;
    return bug;
  }
  <span class="cp">[</span><span class="nx">HttpPost</span><span class="p">(</span><span class="s2">&quot;api/bugs/done&quot;</span><span class="p">)</span><span class="cp">]</span>
  public Bug MoveToDone(<span class="cp">[</span><span class="nx">FromBody</span><span class="cp">]</span> int id)
  {
    var bug = _bugsRepository.GetBugs().First(b =&gt; b.id == id);
    bug.state = &quot;done&quot;;
    return bug;
  }
}
</pre></div>


<p>В API содержится метод для получения набора багов из репозитория, а также ещё несколько методов для перемещения багов между состояниями.  Гораздо больше информации по ASP.NET Web API можно найти на <a href="http://asp.net/web-api">asp.net/web-api</a></p>
<p>Теперь, когда у меня есть контроллер ASP.NET Web API, мне нужно добавить его к своему существующему OWIN-конвееру.  Для этого я просто добавляю следующие строчки в метод Configuration в моём startup class:</p>
<div class="highlight"><pre><span class="n">var</span> <span class="n">config</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HttpConfiguration</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">MapHttpAttributeRoutes</span><span class="p">();</span>
<span class="n">config</span><span class="p">.</span><span class="n">Routes</span><span class="p">.</span><span class="n">MapHttpRoute</span><span class="p">(</span><span class="s">&quot;bugs&quot;</span><span class="p">,</span> <span class="s">&quot;api/{Controller}&quot;</span><span class="p">);</span>
<span class="n">app</span><span class="p">.</span><span class="n">UseWebApi</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
</pre></div>


<p>Как и в случае с Nancy, пакет OWIN для ASP.NET Web API предоставляет extension method UseWebApi, который способствует простой интеграции ASP.NET Web API в мой существующий OWIN-конвеер.  Теперь он состоит из двух компонентов, ASP.NET Web API и Nancy, как показано ниже:</p>
<p><img alt="owin-pipeline-two-components" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure8_hires(en-us,MSDN.10).png" /></p>
<p>Если запрос, попавший в конвеер, подойдёт под одно из правил в роутинге ASP.NET Web API, то ASP.NET Web API обработает его и сгенерирует ответ.  В противном случае запрос продолжит своё движение по конвееру, где его поджидает Nancy.  Если ни один из компонентов конвеера не сможет обработать какой-нибудь запрос, то стандартные компоненты Katana вернут HTTP 404.</p>
<p>Сейчас у меня есть работающее ASP.NET Web API приложение, но к нему никто не обращается из домашней view.  Поэтому я добавлю код по получению данных из API и генерации списка багов в каждом из состояний: отложено, в работе и сделано.  Для этой задачи я использую преимущества Knockout.js, JavaScript Model-View-ViewModel (MVVM) библиотеки.  Больше информации о Knockout вы можете найти на <a href="http://knockoutjs.com">knockoutjs.com</a>.</p>
<p>Для того, чтобы динамически создавать HTML-разметку на клиенте с использованием Knockout, первым делом мне нужно затянуть все баги из ASP.NET Web API и создать viewModel, которую Knockout привяжет к HTML элементам.</p>
<div class="highlight"><pre><span class="nt">&lt;script&gt;</span>
  $(function () {
    var viewModel;
    $.getJSON(&#39;/api/bugs&#39;, function(data) {
      var model = data;
      viewModel = {
        backlog: ko.observableArray(
          model.filter(function(element) { return element.state === &#39;backlog&#39;; })),
        working: ko.observableArray(
          model.filter(function(element) { return element.state === &#39;working&#39;; })),
        done: ko.observableArray(
          model.filter(function(element) { return element.state === &#39;done&#39;; })),
        changeState: function (bug, newState) {
          var self = this;
          $.post(&#39;/api/bugs/&#39; + newState, { &#39;&#39;: bug.id }, function(data){
            self.moveBug(data);
          });
        },
        moveBug: function (bug) {
          // Remove the item from one of the existing lists
          ...
          // Add bug to correct list
          this[bug.state].push(bug);
        }
      };
      ko.applyBindings(viewModel);
    })
  })
<span class="nt">&lt;/script&gt;</span>
</pre></div>


<p>Как только viewModel создана, Knockout может динамически создавать и обновлять содержимое HTML через привязку viewModel к HTML элементам, к которым добавлены специальные атрибуты.  Например, список отложенных багов может быть сгенерирован из viewModel с помощью таких атрибутов:</p>
<div class="highlight"><pre><span class="nt">&lt;section&gt;</span>
  <span class="nt">&lt;h2&gt;</span>Backlog<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;bugs&quot;</span> <span class="na">id=</span><span class="s">&quot;backlog&quot;</span> <span class="na">data-bind=</span><span class="s">&quot;foreach:backlog&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;li&gt;</span>
      [<span class="nt">&lt;span</span> <span class="na">data-bind=</span><span class="s">&quot;text: id&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>] <span class="nt">&lt;span</span> <span class="na">data-bind=</span><span class="s">&quot;text: title&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>:
        <span class="nt">&lt;span</span> <span class="na">data-bind=</span><span class="s">&quot;text: description&quot;</span><span class="nt">&gt;&lt;/span&gt;</span>
      <span class="nt">&lt;ul&gt;</span>
        <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">data-bind=</span><span class="s">&quot;click: $root.changeState.bind($root, $data, &#39;working&#39;)&quot;</span><span class="nt">&gt;</span>Move to working<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>   
        <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">data-bind=</span><span class="s">&quot;click: $root.changeState.bind($root, $data, &#39;done&#39;)&quot;</span><span class="nt">&gt;</span>Move to done<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>   
      <span class="nt">&lt;/ul&gt;</span>
    <span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/section&gt;</span>
</pre></div>


<h2>Добавление моментальных оповещений об изменениях</h2>
<p>Сейчас у меня есть полностью рабочее одностраничное веб-приложение.  Пользователи могут заходить на домашнуюю страницу и перемещать баги между разными состояниями.  Более того, технологии, на которых всё это работает, Nancy и ASP.NET Web API, работают вместе в одном OWIN-конвеере.</p>
<p>Но я собираюсь пойти дальше и сделать так, чтобы разные пользователи могли в реальном времени видеть обновления, сделанные другими пользователями.  Для этого я буду использовать библиотеку SignalR, которая предоставляет клиентское и серверное API для обмена сообщениями между браузером и веб-сервером в реальном времени.  SignalR тоже написан с учётом работы в OWIN-конвеере, поэтому добавить его к моему существующему приложению будет легче пареной репы.</p>
<p>Я буду использовать одну из возможностей SignalR под названием Hubs.  В двух словах, Hub позволяет клиентам и серверам вызывать методы друг друга.  Отличную вводную статью по SignalR можно посмотреть на <a href="http://bit.ly/14WIx1t">bit.ly/14WIx1t</a>.  В моём приложении, ASP.NET Web API при заросе на изменение состояния бага будет обновлять его и затем рассылать обновлённый баг через SignalR Hub во все клиентские браузеры, подсоединённые к приложению.</p>
<p>Я начну с созданию Hub на сервере.  Я не использую никаких других возможностей SignalR и поэтому мой Hub будет состоять всего лишь из такого пустого класа:</p>
<div class="highlight"><pre><span class="k">[HubName(&quot;bugs&quot;)]</span>
<span class="err">public</span> <span class="err">class</span> <span class="err">BugHub</span> <span class="err">:</span> <span class="err">Hub</span>
<span class="err">{</span>
<span class="err">}</span>
</pre></div>


<p>Для того, чтобы что-нибудь послать в Hub из ASP.NET Web API, мне для начала нужно получить экземпляр его runtime context.  Я могу сделать это, добавив следующий код в конструктор BugsController:</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">BugsController</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">_hub</span> <span class="o">=</span> <span class="nx">GlobalHost.ConnectionManager.GetHubContext</span><span class="o">&lt;</span><span class="nx">BugHub</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>Затем я могу разослать обновлённый баг ко всем подсоединённым клиентским бразуером из какого-нибудь метода MoveToXX:</p>
<div class="highlight"><pre><span class="n">_hub</span><span class="p">.</span><span class="n">Clients</span><span class="p">.</span><span class="n">All</span><span class="p">.</span><span class="n">moved</span><span class="p">(</span><span class="n">bug</span><span class="p">);</span>
</pre></div>


<p>На домашней странице, после добавления нескольких JavaScript библиотек SignalR, я могу подсоединиться к bugsHub и начать ждать сообщений об изменениях:</p>
<div class="highlight"><pre><span class="nx">$</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">hub</span><span class="p">.</span><span class="nx">logging</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">bugsHub</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">bugs</span><span class="p">;</span>
<span class="nx">bugsHub</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nx">moved</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">viewModel</span><span class="p">.</span><span class="nx">moveBug</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">hub</span><span class="p">.</span><span class="nx">start</span><span class="p">().</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hub connection open&#39;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>


<p>Заметьте, что когда я получаю с сервера запрос через функцию moved, я вызываю метод moveBug у viewModel также, как я делал это в обработчике клика на элемент списка.  Разница в том, что все клиентские браузеры могут одновременно обновить свои viewModel, так как этот вызов производится через SignalR.  Вы можете убедиться в этом, открыв два окна браузера.  Изменения, сделанные в одном окне, отобразятся в другом.</p>
<p>Как я говорил, добавление SignalR в OWIN-конвеер тривиально.  Я просто добавляю следующий код в метод Configuration у startup class:</p>
<div class="highlight"><pre><span class="n">app</span><span class="p">.</span><span class="n">MapSignalR</span><span class="p">();</span>
</pre></div>


<p>Всё это создаёт такой конвеер:</p>
<p><img alt="owin-pipeline-three-elements" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure11_hires(en-us,MSDN.10).png" /></p>
<h2>Переходим к self-host</h2>
<p>На текущий момент у меня есть работающее приложение по управлению багами, и, хотя ему всё ещё не хватает нескольких важных возможностей, оно уже может делать пару интересных вещей.  Я постепенно добавлял к приложению функциональные блоки, используя как Microsoft-, так и сторонние middleware компоненты.  Справедливо заметить, что многое из этого можно было сделать и с помощью ASP.nET HttpModules и HttpHandlers.  Так чего же я действительно достиг, кроме более простого, ориентированного на код подхода для составления компонентов конвеера вместе?</p>
<p>Для ответа на этот вопрос нужно вспомнить общую схему архитектуры Katana из начала статьи.  До этого момента, я работал только с верхними двумя уровнями стека Katana.  Однако, все эти слои могут быть с лёгкостью заменены, включая сервер и хост.</p>
<p>Чтобы продемонстрировать это, я возьму весь свой конвеер, выкину IIS и System.Web.dll и поставлю всё поверх простого, легковесного HTTP-сервера, который будет хоститься с помощью OwinHost.exe, входящего в состав Katana.  Self-hosting может оказаться полезным в разных сценариях, от случаев, когда на машине разработчика нет Web-сервера, до боевого деплоя на shared-хостинге, который использует изоляцию процессов и не даёт доступа к Web-серверу.</p>
<p>Начну я с установки следующих NuGet пакетов:</p>
<ul>
<li>Microsoft.Owin.Host.HttpListener (<a href="http://bit.ly/153aIca">bit.ly/153aIca</a>)</li>
<li>OwinHost (<a href="http://bit.ly/162Uzj8">bit.ly/162Uzj8</a>)</li>
</ul>
<p>Затем я сделаю ребилд приложения.  Заметьте, что не обязательно делать ребилд для того, чтобы запустить приложения поверх новых сервера и хоста.  Единственным требованием является наличие их файлов в каталоге /bin, а ребилд -- всего лишь удобный способ скопировать эти файлы в /bin.</p>
<p>После того, как пакеты установлены и файлы скопированы, я открываю командную строку, перехожу в корневой каталог веб-проекта и, как это показано ниже, запускаю OwinHost.exe из каталога packages:</p>
<div class="highlight"><pre><span class="cp">..\packages\OwinHost.2.0.0\tools\OwinHost.exe</span>
</pre></div>


<p><img alt="calling OwinHost.exe" src="http://i.msdn.microsoft.com/dn451439.Dierking_Figure%2012_hires(en-us,MSDN.10).png" /></p>
<p>По-умолчанию, OwinHost.exe запустится, загрузит сервер Microsoft.Owin.Host.HttpListener и начнёт слушать порт 5000.  Я могу зайти на http://localhost:5000 и убедиться в том, что приложение работает.</p>
<p>Более того, практически всё настройки могут быть изменены через аргументы командной строки.  Например, если вы хотите слушать на другом порту, передайте -p 12345.  Если вы хотите использовать совершенно другой сервер, передайте -s your.custom.server.assembly.  Сила архитектуры Katana -- модульность.  Как только появилось что-то новое на каком-то уровне стека, оно может быть без промедлений затянуто в работающее приложение.  А так как контракт между всеми компонентами стека -- это всего лишь application delegate, то темп этих изменений может быть гораздо большим, чем это возможно сейчас.</p>
<h2>Просто начните использовать</h2>
<p>Katana 2.0 будет выпущена вместе с Visual Studio 2013.  В новой версии сконцентрировались на двух главных вещах:</p>
<ul>
<li>Предоставление основных инфраструктурных компонентов для self-hosting.</li>
<li>Предоставление богатого набора middleware для аутентификации, включая социальные провайдеры, такие как Facebook, Google, Twitter и Microsoft Account, а также провайдеры для Windows Azure Active Directory, куков и federation (<em>наверное, речь об этом: <a href="http://msdn.microsoft.com/en-us/library/ms730908%28v=vs.110%29.aspx">msdn.microsoft.com/en-us/library/ms730908%28v=vs.110%29.aspx</a> --- прим. перевод.</em>).</li>
</ul>
<p>Как только Katana 2.0 зарелизится, сразу же начнётся работа над следующим набором компонентов Katana.  Детали и приоритеты всё ещё определяются, но вы можете повлиять на обсуждение через заполнение issues на <a href="http://katanaproject.codeplex.com">katanaproject.codeplex.com</a>.  Наконец, весь код из статьи доступен на <a href="http://bit.ly/1alOF4m">bit.ly/1alOF4m</a>.</p>
<hr />
<p><em>Howard Dierking работает на должности program manager в команде Windows Azure Frameworks and Tools, где он сосредоточен на ASP.NET, NuGet и Web API.  Ранее Dierking был редактором MSDN Magazine, а также занимался программой сертификации разработчиков для Microsoft Learning.  До Microsoft он 10 лет был разработчиком и архитектором приложений с уклоном на распределённые системы.</em></p>
<hr />
<p><strong>От переводчика</strong>
В заключение хочу поделиться собственными мыслями по поводу Katana.  В первую очередь меня заинтересовало то, как в Katana используется ASP.NET Identity, новая система аутентификации и авторизации, появившаяся вместе с MVC 5 и остальными октябрьскими релизами в 2013 году.  Identity чертовски просто встраивается в конвеер:</p>
<div class="highlight"><pre><span class="n">appBuilder</span><span class="p">.</span><span class="n">UseGoogleAutentification</span><span class="p">()</span>
</pre></div>


<p>Но есть и подозрительные моменты.  Конечно, сложно спорить с Howard Dierking, управляющим разработкой фреймворков, про которые написано столько книг и статей, что отдельным достижением является прочтение хотя бы половины из них.  Но, с высоты моего скромного опыта, по крайней мере один из аргументов в пользу Katana воспринимается не так однозначно -- возможность собрать все сервисы в одно приложение и деплоить всё сразу.  Ведь известен совершенно противоположный подход -- разделить приложение на отдельные сервисы и получить возможность независимо и постепенно выкладывать обновления на боевую площадку.</p>
<p>Также, могут возникнуть сложности с поиском места в коде, отвечающим за ту или иную функциональность.  Когда запрос может быть обработан кучей разных компонентов и то, какой из них всё-таки отработает, зависит от порядка в конфигурации конвеера и специфичных для каждого компонента настройках, вроде конфига путей в Web API -- искать можно долго.</p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>